+++
draft = false
image = ""
showonlyimage = false
title = "『エリック・エヴァンスのドメイン駆動設計』まとめ"
date = "2021-05-17T22:12:03.284Z"
description = "書籍『エリック・エヴァンスのドメイン駆動設計』のまとめ"
tags = ["本", "ドメイン駆動開発"]
+++


# 序文

**DDDの原則**

- コアドメインに集中すること
- ドメインの実践者とソフトウェアの実践者による創造的な共同作業を通じてモデルを探求すること
- 明示的な境界づけられたコンテキストの内部でユビキタス言語を語ること

**前提**

1. 開発がイテレーティブ(反復的)であること
2. 開発者とドメインエキスパートが密接に関わっている

---

# 第0章

モデル
モデルとは簡素化であり、問題を解決する上で関連する側面を抽象化し、それ以外の詳細を無視することによって行われた**現実に対する一つの解釈**
図を用いて表現する

ドメイン
ソフトウェアプログラムはそれを使用するユーザーの何らかの活動や関心と関係があり、ユーザーがプログラムを適用する対象領域がソフトウェアのドメインである
ドメインは具象も抽象(システムなど)もあり得る

ドメインモデルとは特定の図ではなく、図が伝えようとしている考え方である

## ドメイン駆動設計におけるモデルの有用性

1. モデルと設計の確信が相互に形成し合う
2. モデルはチームメンバー全員が使用する言語の基盤である
3. モデルとは蒸留された知識である…モデルは、ドメインの知識を構成して最も関心のある要素を区別するための、チーム内で取り決めた方法である

ソフトウェアの核心はドメインに関係した問題をユーザーの為に解決する能力である
モンティ・パイソンの例

# 第1章

知識を噛み砕く

## 効果的なモデリングの要素

1. モデルと実装を結びつける
2. モデルに基づいて言語を洗練させる
3. 知識豊富なモデルを開発する
4. モデルを蒸留する
5. ブレインストーミングと実験を行う

**知識の噛み砕き**

**継続的学習**
→**ソフトウェアを書き始める時、我々は対象を十分に理解しているわけではない**

ポリシーも考える必要がある

知識を噛み砕くことによって初めて、ルールが明確となり、具体化され、折り合いがつけられるか、あるいはスコープの対象外とされるのである

# 第2章(コミュニケーションと言語の使い方)

ドメインモデルは、ソフトウェアプロジェクトにおける共通言語のコアとなることができる

モデルとは、プロジェクトに関わる人々の頭の中で構築された概念の塊であり、ドメインについての洞察を反映した用語と概念間の関係性からできている

ドメインエキスパートと開発者での言語の亀裂が問題である

**共通言語（ユビキタス言語）を図やドキュメント、会話の中で用いることユビキタス言語の変更はモデルに対する変更だと思っていること**

ユビキタス言語の語彙には、クラスや主要な操作の名前が含まれていて、また、モデルの中で明示されたルールについて議論するための用語も含まれている

ユビキタス言語は開発者同士、開発者とドメインエキスパート同士で当然の如く用いられてなければならない

ユビキタス言語を用いる上での不便さこそが設計の不備を教えてくれる

**ユビキタス言語における変更は、モデルに対する変更である**

ユビキタス言語は、設計にあってコードに現れない側面を伝達するための主要な手段である

モデルを改良する最適な方法の一つは**話すこと**である

**ドメインエキスパートがモデルを理解できないのなら、モデルに問題がある**

モデルは図ではない

ドキュメントが守るべき指針

1. **すでにコードがうまくやっていることを、ドキュメントでもやろうとするべきでは無い**
2. **ドキュメントは活動の役に立たなければならず、最新の状態に保たなければならない**

# 第3章(モデルと実装を結びつける)

モデルを作るもののコーディングとは結びつかない(あるいは意図的に断絶される)ものが多い

**設計、あるいは設計の中心となる部分がドメインモデルに紐づいていないならばそのモデルにほとんど価値はなく、そのソフトウェアが正確かどうかも疑わしい。分析と設計の間に致命的な亀裂が生じていると、それらの作業で得られる洞察は互いに生かされない**

モデル駆動設計は分析モデルと設計という二分法を捨て去り、両方の目的に使える単一のモデルを探し出す。
**そのモデルは全く別々の二つの目標を満たす必要があるため、我々はモデルに対する要求をもっと厳しくしなければならない**

## ソフトウェアシステムの一部を設計する際には、紐づけが明らかになるように
ドメインモデルを文字通りの意味で忠実に反映させる必要がある。モデルについて再検討し、より自然にソフトウェアに実装されるように修正する。逆にドメインに対する深い洞察を反映させようとするときにも言える。

モデルは全員の共通認識にしなければならない

# 第4章(ドメインを隔離する)

## オブジェクト指向プログラムでは、UI、DB、およびその他の補助的なコードが
ビジネスオブジェクトに直接描かれることはしばしばあるが、ドメイン関連のコードがそうした膨大な他のコード内に拡散してしまうと、コードを見て意味を理解するのが極めて困難になってしまう。

↓
ドメインオブジェクトはシステムの他の昨日から切り離されていなければならない。

**レイヤ化アーキテクチャー**

- UI層(プレゼンテーション層)…ユーザーに情報を提示し、ユーザーのコマンドを解釈する責務を負う
- アプリケーション層…ソフトウェアが行うことになっている仕事を定義し、表現力豊かなドメインオブジェクトが問題を解決するように導く。このレイヤは薄く保たれる。
- ドメイン層(モデル層) …ビジネスの概念と、ビジネスが置かれた状況に関す情報、およびビジネスルールを表す責務を負う。**この層がビジネスソフトウェアの確信である**
- インフラストラクチャ層…上位のレイヤを支える一般的な技術的機能を提供する。
  プロジェクトによってはUI層とアプリケーション層を厳密に区別しなかったり、複数のインフラストラクチャ層を持つこともある。しかし、ドメイン層を分離して初めてモデル駆動開発が可能になる。
  それゆえ、

## 複雑なプログラムはレイヤに分割すること。各レイヤで設計を進め、凝集度を
高めて下位層にだけ依存すること。上位のレイヤに対しては疎結合を保つこと。ドメインモデルに関係するコード全部を一つの層に集中させ、他の層から分離すること。表示や格納、アプリケーションタスク管理などの責務から解放されること。

上位のレイヤは下位のレイヤにある要素を直接使用したり操作したりできる。下位のレイヤにあるオブジェクトが上位と通信しなければならない場合は、コールバックやオブザーバなど、レイヤ同士を関係付ける別のアーキテクチャパターン・仕組みが必要になる。

## アンチパターン「利口なUI」

# 第5章(ソフトウェアで表現されたモデル)

## モデルを表現する3パターン

- **エンティティ**
- **値オブジェクト**
- **サービス** (オブジェクトというより操作やアクションとして捉えた方がいいもの)

また、モデル駆動設計においてモジュールもモデルの一部であり、ドメインにある概念を反映していなければならない

モデリングにおける関連は実装における関連とそれぞれ特性が同じものが存在するべきである
関連を扱いやすくする方法

1. 関連を辿る方向を矯正する
2. 限定子を付加し、多重度を効果的に減らす
3. 本質的ではない関連を除去する
   （例）「国」と「大統領名」の関連

任意のオブジェクトが状態が異なったり別々の実装をまたいだりしても追跡されるような連続性と一意性をもっているか、あるいは他の何かの状態を記述する属性なのか、が**エンティティと値オブジェクトの基本的な区別である**
ドメインの側面んいよってはオブジェクトとしてよりもアクションや操作として表現した方が明確になるものもあり、これらについては**サービス**として扱い、操作を行う責務はエンティティや値オブジェクトに押し付けないのが適切である

**モデルにおいて辿ることのできる関連それぞれに対応して、ソフトウェアにおいても同じ特性を持つ仕組みが存在する**

関連を扱いやすくする方法

1. 関連をたどる方向を強制する
2. 限定子をふかし、多重度を効果的に減らす
3. 本質的ではない関連を除外する

## エンティティ (参照オブジェクト)

多くのオブジェクトは本質的にその属性によってではなく、連続性と同一性によって定義される

## オブジェクトの中には主要な定義が属性によってなされないものもある。そういうオブジェクトは同一性のつながりを表現するものであり、その同一性は時間が経っても異なる形で表現されても変わらない。そういうオブジェクトは属性が異なっていてもほかのオブジェクトと一致しなければならないことがある。また、あるオブジェクトは、同じ属性を持っていたとしても、他のオブジェクトと区別しなければならない

同一性によって定義されるオブジェクトを**エンティティ**と呼ぶ

## あるオブジェクトが属性でなく同一性によって識別されるのであれば、モデルはこのオブジェクトを定義する際にはその同一性を第一とすること。クラスの定義をシンプルに保ち、ライフサイクルの連続性と同一性に集中すること。形式や履歴に関係なく各オブジェクトを識別する手段を定義すること。オブジェクト同士を付き合わせる際に、属性を用いるように求めてくる要件には注意すること。各オブジェクトに対して結果が一位となることが保証される操作を定義すること。モデルは、同じものであるということが何を意味するのかを定義しなければならない

「予約席」はエンティティで「自由席」はエンティティではない

## 値オブジェクト

多くのオブジェクトには概念的な同一性がない

## エンティティの同一性を追跡するのは本質的なことだが、それ以外のオブジェクトに同一性を与えてしまうとシステムの性能を損なうことになり、分析作業が増え、さらに全てのオブクトの見た目が同じになってしまうことでモデルが台無しになりかねない。

値オブジェクトはしばしばオブジェクト間のメッセージでパラメータとして渡される。

## あるモデル要素において、その属性しか関心の対象とならないのであればその要素を値オブジェクトとして分類すること

## サービス

## ドメインから生まれる概念の中には、オブジェクトをモデル化すると不自然なものもある。こうしたドメインで必要な機能をエンティティや値オブジェクトの責務として押し付けると、モデルに基づくオブジェクトの定義を歪めるか、意味のない不自然なオブジェクトを追加することになる

優れたサービスにある三つの特徴

1. 操作がドエミンの概念に関係しており、その概念がエンティティや値オブジェクトの自然な一部ではない
2. ドメインモデルの他の要素の観点からインターフェースが定義されている
3. 操作に状態がない

## モジュール

## モジュールはコードだけでなく概念も分割される。

## モジュールを選択する際には、システムに関する物語を伝え、概念の凝集した集合を含んでいるものを選ぶこと。そうすることでモジュール間は疎結合になることが多い。モジュールにはユビキタス言語の一部になる名前をつけること。モジュールとその名前はドメインに対する洞察を反映しなければならない。

# 第6章(ドメインオブジェクトのライフサイクル)

オブジェクトのライフサイクル(生成から消失まで)において、他のオブジェクトとの間に複雑な相互依存関係がある。
特に、モデル駆動設計において、

1. ライフサイクルを通じて生合成を維持すること
2. ライフサイクルを管理するのが複雑でも、モデルが侵食されないようにする

の二つのカテゴリが課題としてある。
以下、三つのパターンでこれらに対応する。

## 集約(AGGREGATES)

カプセル化と、そのための抽象化が必要。
各集約にはルートと境界がある

- **境界**…集約の内部に何があるか定義する
- **ルート**…集約に含まれている特定の１エンティティ

集約を実装するにあたって、全てのトランザクションに適用できるルールが必要になる

- 集約のルートエンティティはグローバルな同一性を持ち、不変条件をチェックする最終的な責務を負う
- ルートエンティティはグローバルな同一性を持つ。境界内部のエンティティは週やうないでのみ一位となるローカルな同一性を持つ
- 集約の境界外にあるオブジェクトは、ルートオブジェクトを覗き、境界内部への参照を保持できない
- データベースに問い合わせて直接取得出来るのは集約ルートだけである
- 集約内部のオブジェクトは他の集約ルートへの参照を保持できる
- 削除の操作は、集約境界内部に存在するあらゆるものを一度に削除しなければならない
- 集約境界内部に存在するオブジェクトに対する変更がコミットされるときには集約全体の不変条件が全て満たされていなければならない

## エンティティと値オブジェクトを集約の中にまとめ、各集約の周囲に境界を定義すること。各集約に対してルートとなるエンティティを一つ選び、境界内部に存在するオブジェクトへのアクセスは、そのルートを経由して制御する。

## ファクトリ(FACTORIES)

複雑なオブジェクトと集約のインスタンス生成を請け負う

## 集約全体をひとまとまりとして生成し、その不変条件を強制すること

**優れたファクトリの2要件**

- 生成メソッドはそれぞれアトミックであり、生成するオブジェクトや集約の不変条件を全て矯正する
- ファクトリは生成される具象クラスではなく要求される型に応じて抽象化しなければならない(Factory Patern)

## リポジトリ(REPOSITORIES)

## グローバルアクセスを必要とするオブジェクトの各型に対して、あるオブジェクトを生成しその型のすべてのオブジェクトで構成されるコレクションがメモリ上にあると錯覚させること。それによって実際のストレージや問い合わせの技術をカプセル化すること

- 特定の型のオブジェクトを全て概念上の集合として表現する
- コレクションのように振る舞わせる
- 型を抽象化すること
- クライアントから切り離す利点を活かすこと
- トランザクション制御をクライアントに委ねること

**いずれにしてもカプセル化が重要**
# 第7章 言語を使用する

ドメインを隔離する
↓
エンティティと値オブジェクトを区別する
↓
ドメインを設計する
↓
集約の境界を考える
↓
ポジトリを選択する
↓
シナリオをウォークスルーする

# 第9章 暗黙的な概念を明示的にする

## ドメインモデルとそれに対応したコードが大きく変化するのは、議論で示唆されたり、設計の中に暗に存在したりする概念に開発者が気づき、それを一つあるいは複数のオブジェクトや関係性を使ってモデルの中で明示的に表現した時である

ドメインエキスパートの言葉に耳を傾ける
ぎこちなさを精査する

**それほど明白でない概念をモデル化する方法**

# 第10章 しなやかな設計

レガシーの保守をしないでいいようにする

## 意図の明白なインターフェース

## 副作用のない関数

## 表明

操作の事後条件と、クラスおよび集約の不変条件を宣言すること

## 概念の輪郭

設計要素(操作、インターフェース、クラス、集約)を凝集した単位に分解すること

## 独立したクラス



## 閉じた操作

# 第14章 モデルの生合成を維持する

(モデルの境界や他のモデルとの関係性を認識し、伝達し、選択するための章)
